// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: product.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/jackc/pgx/v5/pgtype"
)

const countProducts = `-- name: CountProducts :one
SELECT COUNT(DISTINCT p.product_id) AS total_products 
FROM product p 
LEFT JOIN product_image pi ON pi.product_id = p.product_id
LEFT JOIN category c ON c.category_id = p.category_id
LEFT JOIN manufacturer m ON m.manufacturer_id = p.manufacturer_id
WHERE ($1::integer = 0 OR p.category_id = $1) 
AND ($2::text = '' OR p.tag = $2) 
AND ($3::integer = 0 OR p.price >= $3)
AND ($4::integer = 0 OR p.price <= $4)
AND ($5::text = '' OR p.product_name ILIKE CONCAT('%', $5, '%'))
`

type CountProductsParams struct {
	CategoryID *int32  `json:"category_id"`
	Tag        *string `json:"tag"`
	PriceMin   *int32  `json:"price_min"`
	PriceMax   *int32  `json:"price_max"`
	Search     *string `json:"search"`
}

func (q *Queries) CountProducts(ctx context.Context, arg CountProductsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProducts,
		arg.CategoryID,
		arg.Tag,
		arg.PriceMin,
		arg.PriceMax,
		arg.Search,
	)
	var total_products int64
	err := row.Scan(&total_products)
	return total_products, err
}

const getAllProducts = `-- name: GetAllProducts :many
SELECT 
    p.product_id, 
    p.product_name, 
    p.price, 
    p.stock, 
    p.description, 
    p.discount, 
    p.tag,
    jsonb_build_object('category_id', c.category_id, 'category_name', c.name) AS category,
    jsonb_build_object('manufacturer_id', m.manufacturer_id, 'manufacturer_name', m.manufacturer_name) AS manufacturer,
    COALESCE(jsonb_agg(pi.image_url) FILTER (WHERE pi.image_url IS NOT NULL), '[]'::jsonb) AS images
FROM product p 
LEFT JOIN product_image pi ON pi.product_id = p.product_id
LEFT JOIN category c ON c.category_id = p.category_id
LEFT JOIN manufacturer m ON m.manufacturer_id = p.manufacturer_id
WHERE ($3::integer = 0 OR p.category_id = $3) 
AND ($4::text = '' OR p.tag = $4) 
AND ($5::integer = 0 OR p.price >= $5)
AND ($6::integer = 0 OR p.price <= $6)
AND ($7::text = '' OR p.product_name ILIKE CONCAT('%', $7, '%'))
GROUP BY 
    p.product_id, p.product_name, p.price, p.stock, p.description, p.discount, 
    c.category_id, c.name, 
    m.manufacturer_id, m.manufacturer_name
ORDER BY p.product_id
LIMIT $1 OFFSET $2
`

type GetAllProductsParams struct {
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
	CategoryID int32  `json:"category_id"`
	Tag        string `json:"tag"`
	PriceMin   int32  `json:"price_min"`
	PriceMax   int32  `json:"price_max"`
	Search     string `json:"search"`
}

type GetAllProductsRow struct {
	ProductID    int32           `json:"product_id"`
	ProductName  string          `json:"product_name"`
	Price        pgtype.Numeric  `json:"price"`
	Stock        int32           `json:"stock"`
	Description  *string         `json:"description"`
	Discount     pgtype.Numeric  `json:"discount"`
	Tag          *string         `json:"tag"`
	Category     json.RawMessage `json:"category"`
	Manufacturer json.RawMessage `json:"manufacturer"`
	Images       interface{}     `json:"images"`
}

func (q *Queries) GetAllProducts(ctx context.Context, arg GetAllProductsParams) ([]GetAllProductsRow, error) {
	rows, err := q.db.Query(ctx, getAllProducts,
		arg.Limit,
		arg.Offset,
		arg.CategoryID,
		arg.Tag,
		arg.PriceMin,
		arg.PriceMax,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllProductsRow{}
	for rows.Next() {
		var i GetAllProductsRow
		if err := rows.Scan(
			&i.ProductID,
			&i.ProductName,
			&i.Price,
			&i.Stock,
			&i.Description,
			&i.Discount,
			&i.Tag,
			&i.Category,
			&i.Manufacturer,
			&i.Images,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNewArrivalProducts = `-- name: GetNewArrivalProducts :many
SELECT 
    p.product_id, 
    p.product_name, 
    p.price, 
    p.stock, 
    p.description, 
    p.discount, 
    p.tag,
    jsonb_build_object('category_id', c.category_id, 'category_name', c.name) AS category,
    jsonb_build_object('manufacturer_id', m.manufacturer_id, 'manufacturer_name', m.manufacturer_name) AS manufacturer,
    COALESCE(jsonb_agg(pi.image_url) FILTER (WHERE pi.image_url IS NOT NULL), '[]'::jsonb) AS images
FROM product p 
LEFT JOIN product_image pi ON pi.product_id = p.product_id
LEFT JOIN category c ON c.category_id = p.category_id
LEFT JOIN manufacturer m ON m.manufacturer_id = p.manufacturer_id
WHERE p.tag = 'new'
GROUP BY 
    p.product_id, p.product_name, p.price, p.stock, p.description, p.discount, 
    c.category_id, c.name, 
    m.manufacturer_id, m.manufacturer_name
ORDER BY p.product_id
LIMIT 5
`

type GetNewArrivalProductsRow struct {
	ProductID    int32           `json:"product_id"`
	ProductName  string          `json:"product_name"`
	Price        pgtype.Numeric  `json:"price"`
	Stock        int32           `json:"stock"`
	Description  *string         `json:"description"`
	Discount     pgtype.Numeric  `json:"discount"`
	Tag          *string         `json:"tag"`
	Category     json.RawMessage `json:"category"`
	Manufacturer json.RawMessage `json:"manufacturer"`
	Images       interface{}     `json:"images"`
}

func (q *Queries) GetNewArrivalProducts(ctx context.Context) ([]GetNewArrivalProductsRow, error) {
	rows, err := q.db.Query(ctx, getNewArrivalProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetNewArrivalProductsRow{}
	for rows.Next() {
		var i GetNewArrivalProductsRow
		if err := rows.Scan(
			&i.ProductID,
			&i.ProductName,
			&i.Price,
			&i.Stock,
			&i.Description,
			&i.Discount,
			&i.Tag,
			&i.Category,
			&i.Manufacturer,
			&i.Images,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
