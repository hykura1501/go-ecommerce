// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: product.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/jackc/pgx/v5/pgtype"
)

const countProducts = `-- name: CountProducts :one
SELECT COUNT(*) AS total_products FROM product
`

func (q *Queries) CountProducts(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countProducts)
	var total_products int64
	err := row.Scan(&total_products)
	return total_products, err
}

const getAllProducts = `-- name: GetAllProducts :many
SELECT 
    p.product_id, 
    p.product_name, 
    p.price, 
    p.stock, 
    p.description, 
    p.discount, 
    p.tag,
    jsonb_build_object('category_id', c.category_id, 'category_name', c.name) AS category,
    jsonb_build_object('manufacturer_id', m.manufacturer_id, 'manufacturer_name', m.manufacturer_name) AS manufacturer,
    jsonb_agg(pi.image_url) AS images
FROM product p 
LEFT JOIN product_image pi ON pi.product_id = p.product_id
LEFT JOIN category c ON c.category_id = p.category_id
LEFT JOIN manufacturer m ON m.manufacturer_id = p.manufacturer_id
GROUP BY 
    p.product_id, p.product_name, p.price, p.stock, p.description, p.discount, 
    c.category_id, c.name, 
    m.manufacturer_id, m.manufacturer_name
ORDER BY p.product_id
LIMIT $1 OFFSET $2
`

type GetAllProductsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllProductsRow struct {
	ProductID    int32           `json:"product_id"`
	ProductName  string          `json:"product_name"`
	Price        pgtype.Numeric  `json:"price"`
	Stock        int32           `json:"stock"`
	Description  *string         `json:"description"`
	Discount     pgtype.Numeric  `json:"discount"`
	Tag          *string         `json:"tag"`
	Category     json.RawMessage `json:"category"`
	Manufacturer json.RawMessage `json:"manufacturer"`
	Images       json.RawMessage `json:"images"`
}

func (q *Queries) GetAllProducts(ctx context.Context, arg GetAllProductsParams) ([]GetAllProductsRow, error) {
	rows, err := q.db.Query(ctx, getAllProducts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllProductsRow{}
	for rows.Next() {
		var i GetAllProductsRow
		if err := rows.Scan(
			&i.ProductID,
			&i.ProductName,
			&i.Price,
			&i.Stock,
			&i.Description,
			&i.Discount,
			&i.Tag,
			&i.Category,
			&i.Manufacturer,
			&i.Images,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNewArrivalProducts = `-- name: GetNewArrivalProducts :many
SELECT 
    p.product_id, 
    p.product_name, 
    p.price, 
    p.stock, 
    p.description, 
    p.discount, 
    p.tag,
    jsonb_build_object('category_id', c.category_id, 'category_name', c.name) AS category,
    jsonb_build_object('manufacturer_id', m.manufacturer_id, 'manufacturer_name', m.manufacturer_name) AS manufacturer,
    COALESCE(jsonb_agg(pi.image_url) FILTER (WHERE pi.image_url IS NOT NULL), '[]'::jsonb) AS images
FROM product p 
LEFT JOIN product_image pi ON pi.product_id = p.product_id
LEFT JOIN category c ON c.category_id = p.category_id
LEFT JOIN manufacturer m ON m.manufacturer_id = p.manufacturer_id
WHERE p.tag = 'new'
GROUP BY 
    p.product_id, p.product_name, p.price, p.stock, p.description, p.discount, 
    c.category_id, c.name, 
    m.manufacturer_id, m.manufacturer_name
ORDER BY p.product_id
LIMIT 5
`

type GetNewArrivalProductsRow struct {
	ProductID    int32           `json:"product_id"`
	ProductName  string          `json:"product_name"`
	Price        pgtype.Numeric  `json:"price"`
	Stock        int32           `json:"stock"`
	Description  *string         `json:"description"`
	Discount     pgtype.Numeric  `json:"discount"`
	Tag          *string         `json:"tag"`
	Category     json.RawMessage `json:"category"`
	Manufacturer json.RawMessage `json:"manufacturer"`
	Images       interface{}     `json:"images"`
}

func (q *Queries) GetNewArrivalProducts(ctx context.Context) ([]GetNewArrivalProductsRow, error) {
	rows, err := q.db.Query(ctx, getNewArrivalProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetNewArrivalProductsRow{}
	for rows.Next() {
		var i GetNewArrivalProductsRow
		if err := rows.Scan(
			&i.ProductID,
			&i.ProductName,
			&i.Price,
			&i.Stock,
			&i.Description,
			&i.Discount,
			&i.Tag,
			&i.Category,
			&i.Manufacturer,
			&i.Images,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
